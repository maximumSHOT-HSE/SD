[![Build Status](https://travis-ci.com/maximumSHOT-HSE/SD.svg?branch=master)](https://travis-ci.com/maximumSHOT-HSE/SD)

# CLI

## Инструкция по сборке

Проект собирается с помощью `cmake` и `make`

Будем собирать программу в папке `build`, предполагая, что находимся
в корневой папке проекта.

Нужно:

0. Подключить репозитории со сторонними библиотеками

`git submodule init`

`git submodule update`

1. Создать папку `build`

`mkdir build`

2. Перейти в папку `build`

`cd build`

3. Сгенерировать `Makefile`

`cmake ..`

4. Собрать проект

`make`

5. Запуск

* CLI: `./hw01_cli`

* tests: `cd test && ./hw01_cli_tests`

**Тесты нужно запускать из папки, где лежит собранный бинарный файл с тестами, т.к.
при тестировании ипользуются относительные пути** 

## Архитектура

Лежит в корне в виде файла с расширением `.drawio`.

Его можно загрузить на https://www.draw.io/

## Описание сущностей

### Каналы

Абстракция для передачи данных между процессами, которые выполняются
последовательно (разделяются с помощью `PIPE` (`|`)). 
При этом выходной (`IOutputChannel`) канал передается в качестве 
входного (`IInputChannel`) канала следующему потоку.

В первоначальной реализации везде используется `StringChannel`,
который реализует оба интерфейса (как для чтения, так и для записи).

`StringChannel` хранит в себе строку из символов.
При записи в канал выполняется конкатенация текущего буффера
с аргументом, а при чтении выдается весь буффер наружу, при этом
буффер очищается.

### Токенизация

Есть интерфейс `ITokenizer`. Реализаующие его тоекнизаторы
должны уметь добавлять в себя строку (дописывание строки)
и возвращать следующий токен.

Класс `Token` является единицой для токенизаторов, одной нерушимой частью,
из которых состоит строка. Таким образом основная задача классов, реализующих
интерфейс `ITokenizer` разбивать строку на токены (`Token`).

Класс `LinearTokenzer` реализует интерфейс `ITokenizer` следующим образом:

* Подстроки между двумя кавычками одинаково типа являются одним токеном,
причем если тоен начинается с кавычки, то он закончится **с первой** кавычки того же типа
в строке. Все, что осталось между этими кавычками является одним токеном типа
`LITERAL`. 

* Считает символы `{|(PIPE),=(ASSIGN),$(DOLLAR), (SPACE)}` специальными, для них есть токены специального типа.
Если символ встретился в токене типа `LITERAL` (т.е. оказался между двумя одинаковыми кавычками),
то он **не считается специальным**. Последний символ в множестве - это пробел 
(любой пробельный символ) 

* В качестве самого последнего токена вернет токен типа `END`, после того,
как был вернут `END` дальнейшее использование `LinearTokenizer` может привести
к неопределенному поведению.

### Окружение

* Класс `Environment` представляет из себя оболочку, в которой обарбатывается
хранение переменных, а также работа с утилитами, которые прописаны в `shell`'е
(`cat`, `pwd`, ...)

* Есть поддержка переменной `$?`, в которой хранится код возврата последней операции

### Команды

Для команды есть обертка в виде класса `Command`, которая внутри себя хранит
имя (`CommandName`) и аргументы (`CommandArguments`).

`CommandArguments` представляет из себя массив токенов (`Token`).

`CommandName` - обертка на строкой, которая хранит в себе имя команды.

Команды можно строить посредством строителя `CommandBuilder`, который умеет дописывать
в себе новые токены. Причем, если в нем не было токенов, то первый токен он добавит
только в том случае, если этот токен не пуст (соответствует непустой строке) и
является `LITERA`'ом.

Команды будут вызываться по имени с помощью фабрики `CommadnExecutorFactory`, который
умеет по имени выдавать соответствующий `ICommandExecutor`.

### Подстановка

Для реализации оператора присваивания и подстановки в переменные окружения
был введен класс `Substitutor`. Он не имеет состояния, поэтому все его
методы статические. Этот класс умеет подставлять (конструкция вида `name=value`) значение переменно
вместо конструкции `$name`, если `name` удовлетворяет ограничениями на имя
переменной. Причем подстановка может быть произведена только внутри токенов,
которые ограничены с обоих сторон двойными кавычками. По-умолчанию
переменная имеет значение `""` - пустая строка.

## Команды 

### exit

Реализуется с помощью класса `ExitExecutor`.

Поведение команды:

* Если список аргументов (все непробельные) пуст, то вернется ноль

* Если есть хотя бы один не пробельный аргумент, то если их больше одного,
то или единственный аргумент не может быть преобразован к числу команда не выполнится (т.е. `shell` не закроется и будет возвращен ненулевой
код возврата). Если же есть единственный аргумент в виде числа, то 
`shell` закроется с данным кодом возврата.

### echo

Выводит все свои аргументы, причем предвариетльно удаляет все пробелы
с концов и сжимает длинные блоки (длины больше единицы) в один пробел.

### pwd

Выводит текущую рабочую директорию.

### wc

`wc` считает количество переносов строк, количество слов и количество 
байт в данных.

Может работать в двух режимах

* Если список аргументов пуст, тогда `wc` будет
считывать данные из входного потока.

* Иначе `wc` будет считывать данные из файлов, которые
были переданы в утилиту в качестве аргумнетов. Причем
про каждый файл информация будет считаться и выводиться отдельно 
(также будет выведена информация об имени файла),
а в самом конце информация обо всех данных по всем файлам также
будет выведена. 

Итоговая информация будет выведена в выходной поток.

### cat

Утилита для вывода содержимого входного потока (или файлов) в выходной поток.

Есть два режима работы:

1) Чтение данных из файла. Утилита работает в таком режиме, если
есть **хотя бы один аргумент**, в этом случае данные будут читаться
из файлов в том порядке, в котором они были переданы в качестве аргумнетов
утилите `cat` и в выходной поток запишется конкатенация их содержимого.

2) Чтение данных из входного потока. Утилита будет работать в этом режиме,
если утилите не будет передано ни одного аргумента.

### grep

Утилита для поиска подстрок в тексе (поток ввода или файл).

Первый позиционный аргумент - регулярное выражение. 
По умолчанию регулярное выражение является пустым, т.е.
если ничего не подано в качестве регулярного выражения, то
оно будет пустым.

Второй позиционный аргумент - список файлов, если список пуст, то
данные для анализа будут браться из потока ввода (`stdin` или вывод
предыдущего команды в цепочке из `PIPE`-ов).

Поддерживает набор флагов:

* `-i`: нечувствительность к регистру

* `-w`: поиск только слов целиком

* `-A n`: распечатать `n` строк после строки с совпадением.

    **`n` должно быть неотрицательным числом**. 

    Если строк после совпадения меньше `n`, то будут выведены все из них.

    Если ключ `-A` встречается несколько раз, то в качестве значения будет взято последнее,
    однако если среди значений будет найдено некорректное, то `grep` упадет с ошибкой `failed to parse`. 
    
    Если на вход будут переданы несколько файлов, то входные данные для поиска
    регулярными выражениями будет формироваться конкатенацией содержимых файлов в
    том порядке, в котором они были записаны в аргументах.
    
### Внешние команды

Если на вход `shell`-у передать какую-либо команду, **не входящую**
в список стандартных, то будет запущена утилита внешнего окружения. 

### Процессор

Это основной обработчик команд, поступающих в `shell`.
Сначала он токенизирует всю строку с помощью `LinearTokenizer`'а,
затем проходит по токенам, последовательно выделяет участки между `PIPE`/началом/
концом строки, при этом он строит последний участок с помощью `CommandBuilder`'а, причем
перед каждым `append`'ом он просит `Substitutor`'а подставить переменные окружения.

Затем, после того, как он выделил участок, с помощью `CommandBuilder` строит строку, затем
заново токенизирует (это нужно, т.к. после подстановки переменных все может сломаться).
Строит команду, просит у `Environment` дать соответствующий `CommandExecutor` по имени команды,
вызывает это исполнитель, обновляет статус последней команды. Если последняя команда 
выполнилась неудачно, то процесс останавливается. При исполнении используются `StringChannel`'ы
для передачи данных при исполенни команд.
